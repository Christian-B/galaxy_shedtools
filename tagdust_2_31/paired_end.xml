<tool id="tagdust_paired_end" name="Tagdust paired end processor" version="0.1.1">
    <description>Runs tagdust in paired end mode</description>
    <requirements>
        <requirement type="package" version="2.31">tagdust</requirement>
    </requirements>
    <stdio>
        <exit_code range="1" level="fatal" description="Error code 1 occurred" />
        <exit_code range="2:255" level="fatal" description="Unknown error occurred" />
    </stdio>
    <command >
        cp $read1_file read1.fastq ;
        cp $read2_file read2.fastq ;
        mkdir output ;
        tagdust -t8 -o output/data 
            #if $reference_source.reference_source_selector=='history':
                -ref $reference_source.ref_file
            #else
                -ref $reference_source.ref_path.fields.path
            #end if
            #for $i, $building in enumerate( $hmm, 1 )
                -$i ${building.block}
            #end for
            read1.fastq
            read2.fastq ;
        ls -al output 
    </command>
    <inputs>
        <param name="read1_file" type="data" format="fastq" label="Read 1 Fastq file to process" />
        <param name="read2_file" type="data" format="fastq" label="Read 2 Fastq file to process" />
        <repeat name="hmm" title="HMM Building Blocks">
            <param name="block" type="text" size="25" label="Next HMM Building block (Note: Barcode/Index currently not supported)" />
        </repeat>
        <conditional name="reference_source">
            <param name="reference_source_selector" type="select" label="Choose the source for the reference fasta">
                <option value="cached">Locally cached</option>
                <option value="history">History</option>
            </param>
            <when value="cached">
                <param name="ref_path" type="select" label="Using reference fasta">
                    <options from_data_table="tagdust_index"/>
                    <validator type="no_options" message="A built-in reference fasta is not available for the build associated with the selected input file"/>
                </param>
            </when>
            <when value="history"> 
                <param name="ref_file" type="data" format="fasta" label="Using reference file" />
            </when>
        </conditional>
    </inputs>
    <outputs>
        <data format="txt" name="logfile" label="The tagdust log output for ${read1_file.name}." from_work_dir="output/data_logfile.txt"/>
        <data format="fastq" name="extracted1" label="The tagdust extracted reads from ${read1_file.name}." from_work_dir="output/data_READ1.fq"/>
        <data format="fastq" name="unextracted1" label="The tagdust un-extracted reads from ${read1_file.name}." from_work_dir="output/data_un_READ1.fq"/>
        <data format="fastq" name="extracted2" label="The tagdust extracted reads from ${read2_file.name}." from_work_dir="output/data_READ2.fq"/>
        <data format="fastq" name="unextracted2" label="The tagdust un-extracted reads from ${read2_file.name}." from_work_dir="output/data_un_READ2.fq"/>
    </outputs>
    <tests>
        <!-- Large dataset in github but not toolshed -->
        <!--test>
            <param name="read1_file" value="C75_S29_R1_001_extracted.fastq" ftype="fastq" /> 
            <param name="read2_file" value="C75_S29_R2_001_extracted.fastq" ftype="fastq" /> 
            <param name="hmm_0|block" value="R:N"/>
            <param name="reference_source|reference_source_selector" value="history"/>
            <param name="reference_source|ref_file" value="ercc_and_TPA_mouse_rRNA.fa" ftype="fasta"/>
            <output name="logfile" >
                <assert_contents>
                    <has_text text="Determining threshold for read0." />
                 </assert_contents>
            </output>
            <output name="extracted1" file="C75_S29__READ1.fq" compare="sim_size" delta="10000"/>
            <output name="unextracted1" file="C75_S29__un_READ1.fq"  compare="sim_size" delta="10000"/>
            <output name="extracted2" file="C75_S29__READ2.fq" compare="sim_size" delta="10000"/>
            <output name="unextracted2" file="C75_S29__un_READ2.fq"  compare="sim_size" delta="10000"/>
        </test-->
        <test>
            <param name="read1_file" value="read1_extracted.fastq" ftype="fastq" /> 
            <param name="read2_file" value="read2_extracted.fastq" ftype="fastq" /> 
            <param name="hmm_0|block" value="R:N"/>
            <param name="reference_source|reference_source_selector" value="history"/>
            <param name="reference_source|ref_file" value="ercc_and_TPA_mouse_rRNA.fa" ftype="fasta"/>
            <output name="logfile" >
                <assert_contents>
                    <has_text text="Determining threshold for read0." />
                 </assert_contents>
            </output>
            <output name="extracted1" file="paired_READ1.fq" compare="sim_size" delta="100"/>
            <output name="unextracted1" file="paired_un_READ1.fq"  compare="sim_size" delta="100"/>
            <output name="extracted2" file="paired_READ2.fq" compare="sim_size" delta="100"/>
            <output name="unextracted2" file="paired_un_READ2.fq"  compare="sim_size" delta="100"/>
        </test>
    </tests>
    <help>
<![CDATA[

This tool runs Tagdust2 in paired end mode.

Example HMM BUilding block is:
    R:N

Note: Output from Barcode HMM building block will not be captured by Galaxy.

====

Taken from The TagDust2 Manual http://tagdust.sourceforge.net (part of Version 2_31 download)

Raw sequences produced by next generation sequencing (NGS) machines can contain adapter, linker, 
barcode and fingerprint sequences. TagDust2 is a program to extract and correctly label the sequences
to be mapped in downstream pipelines.
TagDust allows users to specify the expected architecture of a read and converts it into a hidden
Markov model. The latter can assign sequences to a particular barcode (or index) even in the presence
of sequencing errors. Sequences not matching the architecture (primer dimers, contaminants etc.) are
automatically discarded

TagDust requires an input file containing sequences and a user defined HMM architecture used to ex-
tract the reads. The architecture is composed of a selection of pre-defined building blocks representing
indices, barcodes, spacers and other sequences one might encounter in the raw output of a sequenced
sample.

HMM Building Blocks

TagDust comes with a set of pre-defined HMM building blocks. Each includes a silent state at the
beginning and end used to link blocks together. Each block is specified by a unique letter following
by a colon and some information about the sequence.

Read
Segment modeling the read.
Code: R:N

Optional
Segment modeling an optional single or short stretch of nucleotides.
Code: O:N

G addition
Segment modeling the occasional addition of guanines to the reads. 
(89.3% chance of a single G , 19.5% chance of 2 Gs..).
Code: G:G

Barcode or Index
Segment modeling a set of barcode sequences. For each sequence a separate HMM is created. The
barcode sequences must be given as a comma separated list. A null model of the same length as the
barcode is automatically added and initialized to the background nucleotide frequencies.
Code: B:GTA,AAC

Fingerprint or Unique Molecular Identifier - UMI
Segment modeling a fingerprint (or unique molecular identifiers). Insertions and deletions are by
default not allowed within a fingerprint segment.
Code: F:NNN

Spacer
Segment modeling a pre-defined sequence.
Code: S:GTA

Partial
This segment is used to model sequences that may only be partially present at the 5‘ or 3‘ end of
the read. The transition probabilities (orange and blue) are set automatically based on the length
distribution of exactly matching adapters.
Code: P:CCTTAA

]]>
    </help>
    <citations>
    </citations>

</tool>
